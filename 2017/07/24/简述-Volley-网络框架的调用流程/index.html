<html>
  <head>
    <title>简述 Volley 网络框架的调用流程 - learnice</title>
    <link href='/images/fav.png' rel='shortcut icon'>
<link href='/atom.xml' rel='alternate' type='application/rss+xml'>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type'>


  </head>
  <body>
    <header>
  <a id='go-back-home' href='/'><img src='/images/scribble.png' alt='Home' width='66' height='66'></a>
  <p>learnice</p>
  <p>不忘初心</p>
</header>

    <div id='container'>
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='mailto:learnice.he@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/learnice'>Github</a>
  
    <a class='main' href='/about'>About</a>
  
</div>

      <section class='paging'>
  
    <div class='left'>
      <a href='/2017/08/29/不要在-Application-中添加缓存数据作为全局变量/'>
        ‹
      </a>
    </div>
  
  
    <div class='right'>
      <a href='/2017/07/09/Android-源码观后感-触摸事件分发流程/'>
        ›
      </a>
    </div>
  
</section>

      <div class='content'>
        <section class='post'>
          <h1>
            <div class='date'>2017-07-24</div>
            简述 Volley 网络框架的调用流程
          </h1>
          <p>面试好辛苦~~~今天把前段时间在电脑上总结的 Volley 调用的流程呈上来。</p>
<h3 id="Volley-的使用方式"><a href="#Volley-的使用方式" class="headerlink" title="Volley 的使用方式"></a>Volley 的使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Volley.newRequestQueue(mContext).add(request);</div></pre></td></tr></table></figure>
<p>嗯，只有一行，“码”面意思是首先 new 出一个 RequestQueue 然后将request添加进来。</p>
<p>贴一下 StringRequest 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123; 		  				<span class="keyword">super</span>(method, url, errorListener);   </div><div class="line">	mListener = listener;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回调的监听器，也是在 request 中的，errorListener 丢给了父类（这两个回调接口会被后面递送器调用）。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先贴一下 newRequestQueue(mContext) 最终调用的方法方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack, <span class="keyword">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);  <span class="comment">//缓存文件</span></div><div class="line">        <span class="comment">//....这里去掉了一些对分析流程咱是无用的代码</span></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;   <span class="comment">//外部没有传进来网络的方法  就用默认的方法  根据系统版本来选择</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class="line">                <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line">        RequestQueue queue;</div><div class="line">        <span class="keyword">if</span> (maxDiskCacheBytes &lt;= -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">        	<span class="comment">// 没有置顶缓存大小 用默认 5M</span></div><div class="line">        	queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">        	<span class="comment">// 缓存大小制定了 </span></div><div class="line">        	queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class="line">        &#125;</div><div class="line">        queue.start();  <span class="comment">//这个方法下面再说，先看 RequestQueue 这个类</span></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到这个方法主要设置了网络请求要用的方法和缓存的大小。</p>
<p>由此也可以看到，RequestQueue 是 Volley 中的核心类，不信就来看看这个类中还有啥。</p>
<p>紧接着上面看看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;    <span class="comment">//缓存</span></div><div class="line">    mNetwork = network;  <span class="comment">//网络 </span></div><div class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];  <span class="comment">//网络调度器的数组，其实就是个线程的数组，默认是4个</span></div><div class="line">    mDelivery = delivery; <span class="comment">//这个是神奇的递送器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看 RequestQueue 包含了网路请求的所有内容。等等，缓存调度器在哪里？来看看上面提到的 queue.start() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    stop();  <span class="comment">//开始之前 如果调度器不为空 全部停止</span></div><div class="line">  </div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);  <span class="comment">//这个就是缓存线程</span></div><div class="line">    mCacheDispatcher.start();</div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;   <span class="comment">//初始化网络线程 并start</span></div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里缓存队列和网络调度器已经运行起来</p>
<h3 id="添加网络请求"><a href="#添加网络请求" class="headerlink" title="添加网络请求"></a>添加网络请求</h3><p>接下来看看 add(request) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></div><div class="line">        request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Process requests in the order they are added.</span></div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line">        <span class="comment">// 如果这个 request 不设置缓存，直接添加到网络队列 </span></div><div class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 检车是否能够命中缓存</span></div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></div><div class="line">                Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class="line">                <span class="comment">// flight.</span></div><div class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到首先判断一下 request 是否允许缓存，如果不允许直接将 request 添加到网络队列中，如果允许将 request 添加到缓存的队列中。</p>
<p>接下来看看网络调度器和缓存调度器是怎样处理缓存的（调度器就是线程，所以直接看它的 main() 方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    Request&lt;?&gt; request;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//熟悉的死循环</span></div><div class="line">        <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">        <span class="comment">// release previous request object to avoid leaking request object when mQueue is drained.</span></div><div class="line">        request = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 从队列中获取 request </span></div><div class="line">            request = mQueue.take();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="comment">//这个异常，是其它线程调用了当前线程的 interrupt() 才会抛出的  </span></div><div class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123; <span class="comment">//退出的条件  可以去看看那个 RequestQueue.stop() 方法就是将 mQuit 置为 true，然后将线程中断</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">            <span class="comment">// If the request was cancelled already, do not perform the</span></div><div class="line">            <span class="comment">// network request.</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            addTrafficStatsTag(request);</div><div class="line">            <span class="comment">// Perform the network request.   这里就是网络请求了</span></div><div class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// If the server returned 304 AND we delivered a response already,</span></div><div class="line">            <span class="comment">// we're done -- don't deliver a second identical response.</span></div><div class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Parse the response here on the worker thread.</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// Write to cache if applicable.</span></div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Post the response back.</span></div><div class="line">            request.markDelivered();</div><div class="line">            mDelivery.postResponse(request, response);   <span class="comment">//返回成功  递送结果</span></div><div class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            parseAndDeliverNetworkError(request, volleyError);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">            VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            mDelivery.postError(request, volleyError);   <span class="comment">//递送错误</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先说一下死循环的问题，有人说死循环 CPU 不得爆了啊（其实是我说的）。其实不会的，如果队列中有就会一条条的取出来，有条不紊的进行网络请求处理，如果队列中没有数据线程就会被阻塞（这个队列是阻塞队列），所以 CPU  “不会爆”。类似的 Okhttp 中的队列也是阻塞队列。</li>
</ol>
<ol>
<li>递送器的类型是ExecutorDelivery ，在 RequestQueue 可以看到它的构建方法 new ExecutorDelivery(new Handler(Looper.getMainLooper())) ，参数是一个 持有主线程 Lopper 的handle ，可以猜到他就是用来切换线程的。</li>
</ol>
<h3 id="递送"><a href="#递送" class="headerlink" title="递送"></a>递送</h3><p>先来看看 ExecutorDelivery 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成了一个 Executor ，它的作用就是将 execute() 方法的参数在主线程执行。</p>
<p>下面来看一下是如何进行递送的，来看看 ExecutorDelivery的postResponse(request, response) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));  <span class="comment">//将 request 和 response 放到 runnable 中并运行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然是 Runnable 就来看看 ResponseDeliveryRunnable 的 run() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">// If this request has canceled, finish it and don't deliver.</span></div><div class="line">     <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">         mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">     <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">         mRequest.deliverResponse(mResponse.result);  <span class="comment">//这里调用 request 的 deliverResponse() 回调设置的接口，其它的类似</span></div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         mRequest.deliverError(mResponse.error);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">     <span class="comment">// and the request can be finished.</span></div><div class="line">     <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">         mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         mRequest.finish(<span class="string">"done"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></div><div class="line">     <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">         mRunnable.run();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以 StringRequest 为例看一下它的 deliverResponse 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</div><div class="line">        mListener.onResponse(response);  <span class="comment">//调用接口</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递送的作用就是切换线程，让回调在主线程运行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Volley 的源码逻辑还是很简洁的，能基本看懂源码才可以放心大胆的使用哈！</p>
<p>嗯嗯，就是这么简单，一个流程完毕。</p>

          <br>
<p>learnice</p>
<p><img src='/images/scribble3.png' alt='scribble'  width='33' height='33'></p>

        </section>
      </div>
      
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='mailto:learnice.he@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/learnice'>Github</a>
  
    <a class='main' href='/about'>About</a>
  
</div>

    </div>
    <footer>
  <span class='muted'>learnice</span><br>
  <br>
  <br>
</footer>

  </body>
</html>
